<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">    <link rel="stylesheet" href="/biji/temple/defult/style_defult.css">    <script src="/biji/js/jquery.min.js"></script>    <script>window._deel = {url: 'www.xuewen.cn'}</script>    <title>jsp9大内置对象,4个域对象</title></head><body><div id="article"><header class="article-header"><h1 class="article-title"><a>jsp9大内置对象,4个域对象</a></h1><div class="tags"><a href="#h1" title="Jsp的运行过程">Jsp的运行过程</a><a href="#h2" title="Jsp的9大内置对象">Jsp的9大内置对象</a><a href="#h3" title="out对象(JspWriter)">out对象(JspWriter)</a><a href="#h4" title="pageContext对象(域对象)">pageContext对象(域对象)</a><a href="#h5" title="Jsp的四个域对象">Jsp的四个域对象</a><a href="#h6" title="jsp三大指令">jsp三大指令</a><a href="#h7" title="page指令">page指令</a></div></header><article class="article-content"><h2 id="h1">Jsp的运行过程(<mark>Jsp就是一个servlet文件</mark>)</h2><p>第1次访问jsp时：</p><ul><li>1）tomcat服务器把jsp文件翻译成java源文件（work目录下）_01_hello_jsp.java</li><li>2）tomcat服务器把java源文件编译成class字节码 _01_hello_jsp.class</li><li>3）tomcat服务器构造类对象(_01_hello_jsp)</li><li>4）tomcat服务器调用类对象的方法(_01_hello_jsp中的方法)</li></ul><p>第n次访问jsp时：</p><p>1）tomcat服务器调用类对象的方法(_01_hello_jsp中的方法)<br>只走第4步<br>注意：</p><ul><li>1）当jsp文件内容发送变化，那么会重新翻译和编译jsp文件。</li><li>2）如果java源文件和class字节码删除了，第一次访问jsp时，也会重新翻译和编译。</li></ul><p>Jsp的生命周期：</p><ul><li>1）翻译成java源文件（第一次访问时）</li><li>2）java源文件编译成class字节码（已经是servlet类）（第一次访问时）</li><li>3）构造方法（第一次访问时）</li><li>4）_jspInit()方法（第一次访问时）</li><li>5）_jspService方法（第n次访问时）</li><li>6）_jspDestroy()方法</li></ul><p>好了有了这些知识,让我们进入正题吧</p><h2 id="h2">Jsp的9大内置对象</h2><pre class="prettyprint linenums"> 对象名      对应的类型             备注
 request      HttpServletRequest      请求对象，封装请求信息
 response     HttpServletResponse     响应对象，封装响应信息
 config       ServletConfig           servlet配置对象，封装servlet配置信息
 application	ServletContext          servlet的上下文对象，代表整个web应用环境
 session      HttpSession             会话对象。用于保存会话数据
 exception    Throwable              异常对象，用于封装异常信息
 page         Object                代表当前jsp翻译成java类对象
 out         JspWriter               jsp页面缓存对象，相当于带缓存功能的PrintWriter
 pageContext  PageContext            jsp的上下文件对象，代表当前jsp的环境</pre><h2 id="h3">out对象(JspWriter)</h2><ul><li>1）PrintWrite类： 直接往浏览器写出内容 out.write（“内容”）;</li><li>2）JspWriter类： 相当于带缓存的PrintWriter out.write("内容")： 把内容写入缓存区</li></ul><p>当JspWriter缓存区满足以下条件，缓存区内容会写入到PrintWriter中。</p><ul><li>1）缓冲区满了。</li><li>2）刷新缓冲区（JspWriet.flush()）</li><li>3）关闭缓冲区 （&lt;%@page buffer="0kb"%&gt;  buffer属性用于设置Jsp'Writer缓存区大小，默认8KB）</li><li>4）执行完Jsp页面</li></ul><p>方法:</p><ul><li>得到当前缓冲区大小： out.getBufferSize()</li><li>得到当前缓冲区剩余大小： out.getRemaining()</li></ul><h2 id="h4">pageContext对象(域对象)</h2><p>保存数据：</p><ul><li>pageContext.setAttribute(name,object);默认情况，保存到page域中</li><li>pageContext.setAttribute(name,object, int 域范围)可以指定域保存</li></ul><p>域范围：PAGE_SCOPE, REQUET_SCOPE, SESSION_SCOPE , APPLICATION_SCOPE<br>取出数据：</p><ul><li>pageContext.getAttribute(name);默认情况，从page域取出</li><li>pageContext.getAttribute(name, int 域范围)可以指定域取出</li></ul><p>域范围：PAGE_SCOPE, REQUET_SCOPE, SESSION_SCOPE , APPLICATION_SCOPE<br>从四个域中搜索：pageContext.findAttribute(name);<br>搜索顺序： page域-&gt; request域 -&gt; sesion域-&gt; application域</p><h2 id="h5">Jsp的四个域对象</h2><p>域对象作用范围</p><ul><li>page域： 处于同一个jsp页面中数据共享是有效的！！</li><li>request域：处于同一个请求中数据共享是有效的！！（使用转发）</li><li>session域：处于同一个会话中数据共享是有效的！！（同一个session对象）</li><li>application域：处于同一个web应用中数据共享是有效的！！</li></ul><h2 id="h6">jsp三大指令</h2><p>taglib指令</p><p>include指令</p><img src="/biji/htmlFiles/include.png"><p>注意：<br>1）	包含与被包含的页面先合并内容翻译到一个java源文件中，再编译执行一个java文件。<br>（先合并再翻译），叫静态包含（源码包含）<br>2）被包含的页面不要使用全局的html标签。（html/head/title/body）</p><h2 id="h7">page指令</h2><p>page指令主要是用于告诉tomcat服务器如何翻译jsp文件。（jsp-&gt;java文件）</p><img src="/biji/htmlFiles/page.png"></article></div><script src="/biji/temple/defult/global.js"></script></body></html>