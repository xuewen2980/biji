<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">    <link rel="stylesheet" href="/biji/temple/defult/style_defult.css">    <script src="/biji/js/jquery.min.js"></script>    <script>window._deel = {url: 'www.xuewen.cn'}</script>    <title>hibernate对象状态和Session缓存</title></head><body><div id="article"><header class="article-header"><h1 class="article-title"><a>hibernate对象状态和Session缓存</a></h1><div class="tags"><a href="#h1" title="状态">状态</a><a href="#h2" title="Session缓存">Session缓存</a><a href="#h3" title="list()与iterator()查询区别">list()与iterator()查询区别</a><a href="#h4" title="lazy 属性">lazy 属性</a></div></header><article class="article-content"><h2 id="h1">状态</h2><h3>(一)	临时状态</h3><ul><li>1 . 直接new出来的对象</li><li>2. 不处于session的管理(即没有与任何一个session关联)</li><li>3. 对象在数据库中没有对应的记录！</li></ul><p>    new Employee().setId(2);  只要主键在数据库中存在，就说这个对象在数据库中有对应记录！</p><h3>(二)	持久化状态</h3><ul><li>1. 处于session的管理范围</li></ul><p>    当执行session的方法如：save/update/saveOrUpdate/get/load<br>    对象就会自动转变为持久化状态！</p><ul><li>2. 在数据库中有对应的记录</li></ul><ul><li>3. 处于持久化状态的对象，当对对象属性进行更改的时候，提交事务更改会反映到数据库中！</li></ul><h3>(三)	游离状态</h3><ul><li>1. 对象不处于session的管理范围；  通常指session关闭后对象的状态</li><li>2. 对象在数据库中有对应的记录</li></ul><h2 id="h2">Session缓存</h2><div class="sc_act">Session缓存，也叫做一级缓存！ 当执行session的相关方法，如: save()/update()/get()/load()等方法的时候，对象会自动放入一级缓存中。当Session关闭后，一级缓存内容失效！</div><p>特点：</p><ul><li>1）缓存有效范围，只在当前session范围内有效！ 缓存时间很短、作用范围小！</li><li>2）一级缓存，可以在短时间内多次操作数据库的时候，才会明显提升效率！</li></ul><p>    一级缓存的结构：Map&lt;主键，对象&gt;</p><ul><li>3）在提交事务时候，Hibernate会同步缓存数据到数据库中，会对比缓存数据与数据库数据是否一致，如果不一致，才操作数据库</li><li>4) hibernate提供的一级缓存有hibernate自身维护，如果想操作一级缓存内容，必须通过hibernate提供的方法；</li></ul><p>    session.flush();  手动让让一级缓存内容与数据库同步<br>    session.evict(emp1);  清空一级缓存中对象:  清除指定的对象<br>    session.clear();  清空一级缓存中对象:  清除所有的对象</p><h2 id="h3">list()与iterator()查询区别</h2><h3>list:  (<mark>通常使用频率较高</mark>)</h3><p>Query接口定义的list查询方法，一次查询所有满足需要的数据！</p><h3>iterator:</h3><p>Query接口定义的iterator查询方法，</p><ul><li>1. 先查询所有满足条件记录的主键   （查询1次）</li><li>2. 再根据每一个id，进行主键查询，有多少记录，查询多少次  （查询n次）</li><li>3. iterator查询：  N + 1</li><li>4. iterator查询，迭代数据的时候，只有用到数据的时候，才会查找数据库(懒加载)</li></ul><h2 id="h4">lazy 属性</h2><div class="sc_act">Hibernate为了提升程序运行效率，提供了懒加载！而lazy属性表示懒加载！</div><ul><li>true   支持懒加载(默认)</li><li>false   关闭懒加载</li><li>extra  (集合属性时候使用)</li></ul><p><mark>懒加载：  用到数据的时候，才向数据库发送查询的sql！</mark></p><h3>(1) 主键查询(get/load)：</h3><ul><li>get: 及时加载, 只要get就立刻查询数据库，如果查询的主键不存在，返回null</li><li>Load:懒加载， 只有在用到数据的时候，才向数据库发送sql语句！如果查询的主键不存在，只要使用就报错！</li></ul><h3>(2) 懒加载作用位置</h3><ul><li>类级别，默认支持懒加载，但只有在使用load使用才会应用这个特性！</li><li>字段级别， 普通字段无效，大数据类型会有影响(long/longtext)</li><li>集合属性， 默认支持懒加载</li></ul><h3>(3) 懒加载异常</h3><div class="sc_act">org.hibernate.LazyInitializationException: could not initialize proxy - no Session</div><p>解决思路：</p><ul><li>在关闭后，不能能懒加载数据， 那么就要求关闭前把懒加载使用的数据先查询出来！</li><li>强迫代理对象初始化:使用Hibernate.initialize(Object proxy))</li></ul></article></div><script src="/biji/temple/defult/global.js"></script></body></html>